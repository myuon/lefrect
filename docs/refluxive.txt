-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/myuon/refluxive#readme</a>
@package refluxive
@version 0.1.0.0


-- | Provides graphical functions
module Graphics.UI.Refluxive.Graphical

-- | <a>Graphical</a> object can be displayed on screen with <a>render</a>
data Graphical

-- | A rendering context
data RenderState
RenderState :: Color -> Pos -> Pos -> RenderState
[color] :: RenderState -> Color
[coordinate] :: RenderState -> Pos
[scaler] :: RenderState -> Pos

-- | Default rendering state
defRenderState :: RenderState

-- | A function to draw <a>Graphical</a> objects
render :: MonadIO m => Color -> Maybe Font -> Renderer -> Graphical -> (RenderState -> String -> m ()) -> m ()

-- | Empty object
empty :: Graphical

-- | Line object
lineTo :: Pos -> Pos -> Graphical

-- | Line object, as target position is calculated relatively
relLineTo :: Pos -> Pos -> Graphical

-- | Text object (font family and size is currently hard-coded)
text :: Text -> Graphical

-- | Text object with text style
textWith :: IncludeAssoc TextStyle xs => Record xs -> Text -> Graphical

-- | Text style for <a>text</a> object
type TextStyle = '["styles" >: [Style]]

-- | Scaling function, useful to place objects in grid
gridLayout :: Pos -> Graphical -> Graphical

-- | Rectangle object
--   
--   <pre>
--   rectangle == rectangleWith nil
--   </pre>
rectangle :: Pos -> Pos -> Graphical

-- | Rectangle object with shape style
rectangleWith :: IncludeAssoc ShapeStyle xs => Record xs -> Pos -> Pos -> Graphical

-- | Shape style for <a>rectangle</a> object
type ShapeStyle = ["fill" >: Bool, "rounded" >: Maybe Int]

-- | Possible styles that can be applied to a <a>Font</a>.
data Style
Bold :: Style
Italic :: Style
Underline :: Style
Strikethrough :: Style

-- | Coloring function
colored :: Color -> Graphical -> Graphical

-- | Coordinate translating function
translate :: Pos -> Graphical -> Graphical

-- | Many graphical objects
graphics :: [Graphical] -> Graphical

-- | Clipping function
clip :: Pos -> Graphical -> Graphical

-- | Tagging id with given graphical (like CSS id)
viewInfo :: String -> Graphical -> Graphical


-- | UI Components
module Graphics.UI.Refluxive.Component

-- | Component type
class KnownSymbol a => Component m a | a -> m where {
    type family ModelParam a;
    data family Model a;
    data family Signal a;
}

-- | Creating new model from <a>ModelParam</a>, it is called internally in
--   new function
newModel :: (Component m a, MonadIO m) => ModelParam a -> m (Model a)

-- | Initialize function, it is called internally after new function
initComponent :: (Component m a, MonadIO m) => ComponentView a -> m ()

-- | Projecting model to view
getGraphical :: (Component m a, MonadIO m) => Model a -> m Graphical

-- | An instance for Component
data ComponentView a
ComponentView :: IORef (Model a) -> String -> IORef RenderState -> ComponentView a
[modelRef] :: ComponentView a -> IORef (Model a)
[name] :: ComponentView a -> String
[renderStateRef] :: ComponentView a -> IORef RenderState

-- | Watcher type with context <tt>m</tt> and target ui name <tt>tgt</tt>
data Watcher m tgt
Watcher :: (ComponentView src) -> (RenderState -> Signal src -> StateT (Model tgt) m ()) -> Watcher m tgt

-- | Get current model
getModel :: MonadIO m => ComponentView a -> m (Model a)
prefix :: Component m a => proxy a -> String


-- | Refluxive framework
module Graphics.UI.Refluxive

-- | UI monad
data UI a

-- | Running UI monad
runUI :: UI () -> IO ()

-- | Start a mainloop, render given components as root
mainloop :: [SomeComponent] -> UI ()

-- | Register a ComponentView to refluxive framework
register :: Component UI a => ComponentView a -> UI ()

-- | Emit a signal from a component
emit :: Component UI a => ComponentView a -> Signal a -> UI ()

-- | Watcher function
watch :: (Component UI src, Component UI tgt) => ComponentView src -> (RenderState -> Signal src -> StateT (Model tgt) UI ()) -> Watcher UI tgt

-- | A function which is used for passing to mainloop
asRoot :: Component UI a => ComponentView a -> SomeComponent

-- | Set background color
setClearColor :: Color -> UI ()

-- | Add a watch signal
addWatchSignal :: Component UI tgt => ComponentView tgt -> Watcher UI tgt -> UI ()

-- | Quit the mainloop
quit :: UI ()

-- | Register a graphical object to raw component | This will override the
--   previous graphical
rawGraphical :: ComponentView "raw" -> Graphical -> UI ()

-- | A lens to focus on builtIn component
_builtIn :: Lens' UIState (ComponentView "builtin")

-- | Component type
class KnownSymbol a => Component m a | a -> m where {
    type family ModelParam a;
    data family Model a;
    data family Signal a;
}

-- | Creating new model from <a>ModelParam</a>, it is called internally in
--   new function
newModel :: (Component m a, MonadIO m) => ModelParam a -> m (Model a)

-- | Initialize function, it is called internally after new function
initComponent :: (Component m a, MonadIO m) => ComponentView a -> m ()

-- | Projecting model to view
getGraphical :: (Component m a, MonadIO m) => Model a -> m Graphical

-- | An instance for Component
data ComponentView a

-- | Watcher type with context <tt>m</tt> and target ui name <tt>tgt</tt>
data Watcher m tgt

-- | Get current model
getModel :: MonadIO m => ComponentView a -> m (Model a)

-- | Constructor of a component
new :: Component UI a => ModelParam a -> UI (ComponentView a)

-- | Get the view with current snapshot of model
view :: (Component UI a) => ComponentView a -> UI Graphical

-- | Modify internal model of a component
operateModel :: Component UI a => ComponentView a -> StateT (Model a) UI r -> UI r
instance Graphics.UI.Refluxive.Component.Component Graphics.UI.Refluxive.UI "builtin"
instance Control.Monad.State.Class.MonadState Graphics.UI.Refluxive.UIState Graphics.UI.Refluxive.UI
instance Graphics.UI.Refluxive.Component.Component Graphics.UI.Refluxive.UI "raw"
instance Control.Monad.IO.Class.MonadIO Graphics.UI.Refluxive.UI
instance GHC.Base.Monad Graphics.UI.Refluxive.UI
instance GHC.Base.Applicative Graphics.UI.Refluxive.UI
instance GHC.Base.Functor Graphics.UI.Refluxive.UI


-- | Checkbox component
module Data.Refluxive.UI.Checkbox

-- | Checkbox state (checked? or not)
checkState :: Lens' (Model "checkbox") Bool

-- | Change event listener for checkbox component | The third argument is a
--   callback, which recieves <a>RenderState</a> and current
--   (after-changed) checkbox state
onChanged :: Component UI tgt => ComponentView "checkbox" -> ComponentView tgt -> (RenderState -> Bool -> StateT (Model tgt) UI ()) -> UI ()
instance Graphics.UI.Refluxive.Component.Component Graphics.UI.Refluxive.UI "checkbox"


-- | Button component
module Data.Refluxive.UI.Button

-- | Button Label
label :: Lens' (Model "button") Text

-- | Button Size
size :: Lens' (Model "button") Pos

-- | <a>ButtonState</a>
buttonState :: Lens' (Model "button") ButtonState

-- | Internal state
data ButtonState
None :: ButtonState
Hover :: ButtonState
Clicking :: ButtonState

-- | Click event listener for button component
onClick :: Component UI tgt => ComponentView "button" -> ComponentView tgt -> (RenderState -> StateT (Model tgt) UI ()) -> UI ()
instance GHC.Classes.Eq Data.Refluxive.UI.Button.ButtonState
instance Graphics.UI.Refluxive.Component.Component Graphics.UI.Refluxive.UI "button"
